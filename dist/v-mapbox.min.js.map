{"version":3,"file":"v-mapbox.min.js","sources":["../src/utils/symbols.ts","../src/utils/index.ts","../src/controls/VControlAttribution.vue","../src/controls/VControlFullscreen.vue","../src/constants/events/geolocate.ts","../src/controls/VControlGeolocate.vue","../src/controls/VControlNavigation.vue","../src/controls/VControlScale.vue","../src/layers/deck.gl/VLayerDeckArc.vue","../src/layers/deck.gl/VLayerDeckGeojson.vue","../src/layers/mapbox/VLayerMapboxCanvas.vue","../src/constants/events/layer.ts","../src/constants/events/map.ts","../src/constants/events/marker.ts","../src/constants/events/popup.ts","../src/layers/mapbox/VLayerMapboxGeojson.vue","../src/layers/mapbox/VLayerMapboxImage.vue","../src/layers/mapbox/VLayerMapboxRaster.vue","../src/layers/mapbox/VLayerMapboxVector.vue","../src/layers/mapbox/VLayerMapboxVideo.vue","../src/map/VMap.vue","../src/map/VMap.vue?vue&type=template&id=2e23fe52&lang.js","../src/popups/VPopup.vue","../src/popups/VPopup.vue?vue&type=template&id=bc809c96&lang.js","../src/markers/VMarker.vue","../src/markers/VMarker.vue?vue&type=template&id=7aa7f85e&lang.js"],"sourcesContent":["import type { Map } from 'mapbox-gl';\nimport type { InjectionKey, Ref } from 'vue';\n\nconst MapKey: InjectionKey<Ref<Map>> = Symbol('Map');\n\nexport { MapKey };\n","import type { InjectionKey } from 'vue';\nimport { inject } from 'vue';\n\n/**\n * Dependency injection ðŸ¥³\n *\n * @param {InjectionKey} key - The key to inject\n * @param {string | undefined} fallback - The fallback value\n * @returns {undefined} - The value\n */\nexport function injectStrict<T>(key: InjectionKey<T>, fallback?: T): T {\n  const resolved = inject(key, fallback);\n  if (!resolved) {\n    throw new Error(`Could not resolve ${key.description}`);\n  }\n  return resolved;\n}\n\nexport { MapKey } from './symbols';\n","<template>\n  <div>\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import { AttributionControl } from 'mapbox-gl';\n  import type { PropType } from 'vue';\n  import { defineComponent, onMounted } from 'vue';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VControlAttribution',\n    props: {\n      options: {\n        type: Object as PropType<{\n          compact?: boolean;\n          customAttribution?: string | string[];\n        }>,\n        default: () => ({\n          compact: false,\n          customAttribution: 'Map design by me',\n        }),\n        required: true,\n      },\n      position: {\n        type: String as PropType<\n          'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'\n        >,\n        default: () => 'bottom-right',\n        required: false,\n      },\n    },\n    setup(props, { slots }) {\n      let map = injectStrict(MapKey);\n\n      onMounted(() => {\n        addControl();\n      });\n\n      /**\n       * Adds the Attribution Control\n       *\n       * @returns {void}\n       */\n      function addControl(): void {\n        const options = {\n          ...props.options,\n        };\n        if (slots && slots.default!() && Array.isArray(slots.default!())) {\n          // @ts-ignore\n          options.customAttribution = slots.default().at(0).el.data;\n        }\n        const control = new AttributionControl(options);\n        map.value.addControl(control, props.position);\n      }\n    },\n  });\n</script>\n","<script lang=\"ts\">\n  import type { FullscreenControlOptions } from 'mapbox-gl';\n  import { FullscreenControl } from 'mapbox-gl';\n  import type { PropType } from 'vue';\n  import { defineComponent, onMounted } from 'vue';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VControlFullscreen',\n    props: {\n      options: {\n        type: Object as PropType<FullscreenControlOptions>,\n        default: () => ({}),\n        required: true,\n      },\n      position: {\n        type: String as PropType<\n          'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'\n        >,\n        default: () => 'top-left',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n\n      onMounted(() => {\n        addControl();\n      });\n\n      /**\n       * Adds the Attribution Control\n       *\n       * @returns {void}\n       */\n      function addControl(): void {\n        const control = new FullscreenControl(props.options);\n        map.value.addControl(control, props.position);\n      }\n    },\n  });\n</script>\n","export const geolocateControlEvents: string[] = [\n  'geolocate',\n  'error',\n  'outofmaxbounds',\n  'trackuserlocationstart',\n  'trackuserlocationend',\n];\n","<script lang=\"ts\">\n  import type { FitBoundsOptions, PositionOptions } from 'mapbox-gl';\n  import { GeolocateControl } from 'mapbox-gl';\n  import type { PropType } from 'vue';\n  import { defineComponent, onMounted } from 'vue';\n  import { geolocateControlEvents as events } from '../constants/events/geolocate';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VControlFullscreen',\n    props: {\n      options: {\n        type: Object as PropType<{\n          positionOptions?: PositionOptions;\n          fitBoundsOptions?: FitBoundsOptions;\n          trackUserLocation?: boolean;\n          showAccuracyCircle?: boolean;\n          showUserLocation?: boolean;\n        }>,\n        default: () => ({}),\n        required: true,\n      },\n      position: {\n        type: String as PropType<\n          'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'\n        >,\n        default: () => 'top-left',\n        required: false,\n      },\n    },\n    setup(props, { emit }) {\n      let map = injectStrict(MapKey);\n\n      onMounted(() => {\n        addControl();\n      });\n\n      /**\n       * Adds the Attribution Control\n       *\n       * @returns {void}\n       */\n      function addControl(): void {\n        const control = new GeolocateControl(props.options);\n        map.value.addControl(control, props.position);\n        events.forEach((event: string) => {\n          control.on(event, () => {\n            emit(event);\n          });\n        });\n      }\n    },\n  });\n</script>\n","<script lang=\"ts\">\n  import { NavigationControl } from 'mapbox-gl';\n  import type { PropType } from 'vue';\n  import { defineComponent, onMounted } from 'vue';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VControlFullscreen',\n    props: {\n      options: {\n        type: Object as PropType<{\n          showCompass?: boolean;\n          showZoom?: boolean;\n          visualizePitch?: boolean;\n        }>,\n        default: () => ({}),\n        required: true,\n      },\n      position: {\n        type: String as PropType<\n          'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'\n        >,\n        default: () => 'top-left',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n\n      onMounted(() => {\n        addControl();\n      });\n\n      /**\n       * Adds the Attribution Control\n       *\n       * @returns {void}\n       */\n      function addControl(): void {\n        const control = new NavigationControl(props.options);\n        map.value.addControl(control, props.position);\n      }\n    },\n  });\n</script>\n","<script lang=\"ts\">\n  import { ScaleControl } from 'mapbox-gl';\n  import type { PropType } from 'vue';\n  import { defineComponent, onMounted } from 'vue';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VControlFullscreen',\n    props: {\n      options: {\n        type: Object as PropType<{ maxWidth?: number; unit?: string }>,\n        default: () => ({}),\n        required: true,\n      },\n      position: {\n        type: String as PropType<\n          'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'\n        >,\n        default: () => 'bottom-left',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n\n      onMounted(() => {\n        addControl();\n      });\n\n      /**\n       * Adds the Attribution Control\n       *\n       * @returns {void}\n       */\n      function addControl(): void {\n        const control = new ScaleControl(props.options);\n        map.value.addControl(control, props.position);\n      }\n    },\n  });\n</script>\n","<script lang=\"ts\">\n  // @ts-ignore\n  import { ArcLayer } from '@deck.gl/layers';\n  // @ts-ignore\n  import { MapboxLayer } from '@deck.gl/mapbox';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n\n  export default defineComponent({\n    name: 'VLayerDeckArc',\n    props: {\n      layerId: {\n        type: String as PropType<string>,\n        default: 'deck.gl-arc-layer',\n        required: true,\n      },\n      data: {\n        type: Object as PropType<any>,\n        required: true,\n      },\n      options: {\n        type: Object,\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n\n      const layer = new MapboxLayer({\n        ...props.options,\n        id: props.layerId,\n        data: props.data,\n        type: ArcLayer,\n      });\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      onMounted(() => {\n        addLayer();\n      });\n\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","<script lang=\"ts\">\n  // @ts-ignore\n  import { GeoJsonLayer } from '@deck.gl/layers';\n  // @ts-ignore\n  import { MapboxLayer } from '@deck.gl/mapbox';\n  import { FeatureCollection } from 'geojson';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n\n  export default defineComponent({\n    name: 'VLayerDeckGeojson',\n    props: {\n      layerId: {\n        type: String as PropType<string>,\n        default: 'deck.gl-geojson-layer',\n        required: true,\n      },\n      data: {\n        type: Object as PropType<FeatureCollection>,\n        required: true,\n      },\n      options: {\n        type: Object,\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n\n      const layer = new MapboxLayer({\n        ...props.options,\n        id: props.layerId,\n        data: props.data,\n        type: GeoJsonLayer,\n      });\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      onMounted(() => {\n        addLayer();\n      });\n\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","<template>\n  <div>\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type { FeatureCollection } from 'geojson';\n  import type { AnyLayer, GeoJSONSourceRaw } from 'mapbox-gl';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n\n  export default defineComponent({\n    name: 'VLayerMapboxCanvas',\n    props: {\n      sourceId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-canvas-source',\n        required: true,\n      },\n      layerId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-canvas-layer',\n        required: true,\n      },\n      source: {\n        type: Object as PropType<FeatureCollection>,\n        required: true,\n      },\n      layer: {\n        type: Object as PropType<AnyLayer>,\n        default: () => ({}),\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n\n      const layer = {\n        ...props.layer,\n        id: props.layerId,\n        source: props.sourceId,\n      };\n      const source: GeoJSONSourceRaw = {\n        type: 'geojson',\n        data: props.source,\n      };\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      onMounted(() => {\n        addLayer();\n      });\n\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addSource(props.sourceId, source);\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","import { MapLayerEventType } from 'mapbox-gl';\n\nexport const mapLayerEvents: Array<keyof MapLayerEventType> = [\n  'click',\n  'dblclick',\n  'mousedown',\n  'mouseup',\n  'mousemove',\n  'mouseenter',\n  'mouseleave',\n  'mouseover',\n  'mouseout',\n  'contextmenu',\n  'touchstart',\n  'touchend',\n  'touchcancel',\n];\n","import { MapEventType } from 'mapbox-gl';\n\nexport const mapEvents: Array<keyof MapEventType> = [\n  'error',\n  'load',\n  'idle',\n  'remove',\n  'render',\n  'resize',\n  'webglcontextlost',\n  'webglcontextrestored',\n  'dataloading',\n  'data',\n  'tiledataloading',\n  'sourcedataloading',\n  'styledataloading',\n  'sourcedata',\n  'styledata',\n  'boxzoomcancel',\n  'boxzoomstart',\n  'boxzoomend',\n  'touchcancel',\n  'touchmove',\n  'touchend',\n  'touchstart',\n  'click',\n  'contextmenu',\n  'dblclick',\n  'mousemove',\n  'mouseup',\n  'mousedown',\n  'mouseout',\n  'mouseover',\n  'movestart',\n  'move',\n  'moveend',\n  'zoomstart',\n  'zoom',\n  'zoomend',\n  'rotatestart',\n  'rotate',\n  'rotateend',\n  'dragstart',\n  'drag',\n  'dragend',\n  'pitchstart',\n  'pitch',\n  'pitchend',\n  'wheel',\n];\n","export const markerMapEvents = ['dragstart', 'drag', 'dragend'];\nexport const markerDOMEvents = ['click', 'mouseenter', 'mouseleave'];\n","export const popupEvents = ['open', 'close'];\n","<template>\n  <div>\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type {\n    AnyLayer,\n    GeoJSONSourceRaw,\n    MapLayerEventType,\n  } from 'mapbox-gl';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, onBeforeUnmount, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n  import { mapLayerEvents } from '../../constants/events';\n\n  export default defineComponent({\n    name: 'VLayerMapboxGeojson',\n    props: {\n      sourceId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-geojson-source',\n        required: true,\n      },\n      layerId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-geojson-layer',\n        required: true,\n      },\n      source: {\n        type: Object as PropType<GeoJSONSourceRaw>,\n        required: true,\n      },\n      layer: {\n        type: Object as PropType<AnyLayer>,\n        default: () => ({}),\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props, { emit }) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n      let events: Ref<Array<keyof MapLayerEventType>> = ref(mapLayerEvents);\n\n      const layer = {\n        ...props.layer,\n        id: props.layerId,\n        source: props.sourceId,\n      };\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      watch(() => props.source, (source, prevSource) => {\n        map.value.getSource(props.sourceId).setData(source.data)\n      });\n\n      onMounted(() => {\n        addLayer();\n        listenLayerEvents();\n      });\n\n      /**\n       * Listen to layer events\n       *\n       * @returns {void}\n       */\n      function listenLayerEvents(): void {\n        // Listen for events\n        events.value.forEach((e) => {\n          map.value.on(e, props.layerId, (evt) => {\n            emit(e, evt);\n          });\n        });\n      }\n\n      onBeforeUnmount(() => {\n        removeLayer()\n      });\n\n      function removeLayer(): void {\n        if (map.value.getLayer(props.layerId)) {\n          map.value.removeLayer(props.layerId);\n          map.value.removeSource(props.sourceId);\n        }\n      };\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addSource(props.sourceId, props.source);\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","<template>\n  <div>\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type { AnyLayer, ImageSourceRaw } from 'mapbox-gl';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n\n  export default defineComponent({\n    name: 'VLayerMapboxImage',\n    props: {\n      sourceId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-image-source',\n        required: true,\n      },\n      layerId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-image-layer',\n        required: true,\n      },\n      source: {\n        type: Object as PropType<ImageSourceRaw>,\n        required: true,\n      },\n      layer: {\n        type: Object as PropType<AnyLayer>,\n        default: () => ({}),\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n\n      const layer = {\n        ...props.layer,\n        id: props.layerId,\n        source: props.sourceId,\n      };\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      onMounted(() => {\n        addLayer();\n      });\n\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addSource(props.sourceId, props.source);\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","<template>\n  <div>\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type { FeatureCollection } from 'geojson';\n  import type { AnyLayer, GeoJSONSourceRaw } from 'mapbox-gl';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n\n  export default defineComponent({\n    name: 'VLayerMapboxRaster',\n    props: {\n      sourceId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-raster-source',\n        required: true,\n      },\n      layerId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-raster-layer',\n        required: true,\n      },\n      source: {\n        type: Object as PropType<FeatureCollection>,\n        required: true,\n      },\n      layer: {\n        type: Object as PropType<AnyLayer>,\n        default: () => ({}),\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n\n      const layer = {\n        ...props.layer,\n        id: props.layerId,\n        source: props.sourceId,\n      };\n      const source: GeoJSONSourceRaw = {\n        type: 'geojson',\n        data: props.source,\n      };\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      onMounted(() => {\n        addLayer();\n      });\n\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addSource(props.sourceId, source);\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","<template>\n  <div>\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type { AnyLayer, VectorSource } from 'mapbox-gl';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n\n  export default defineComponent({\n    name: 'VLayerMapboxVector',\n    props: {\n      sourceId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-vector-source',\n        required: true,\n      },\n      layerId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-vector-layer',\n        required: true,\n      },\n      source: {\n        type: Object as PropType<VectorSource>,\n        required: true,\n      },\n      layer: {\n        type: Object as PropType<AnyLayer>,\n        default: () => ({}),\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n\n      const layer = {\n        ...props.layer,\n        id: props.layerId,\n        source: props.sourceId,\n      };\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      onMounted(() => {\n        addLayer();\n      });\n\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addSource(props.sourceId, props.source);\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","<template>\n  <div>\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type { AnyLayer, VectorSource } from 'mapbox-gl';\n  import type { PropType, Ref } from 'vue';\n  import { defineComponent, onMounted, ref, watch } from 'vue';\n  import { injectStrict, MapKey } from '../../utils';\n\n  export default defineComponent({\n    name: 'VLayerMapboxVideo',\n    props: {\n      sourceId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-video-source',\n        required: true,\n      },\n      layerId: {\n        type: String as PropType<string>,\n        default: 'mapbox.gl-video-layer',\n        required: true,\n      },\n      source: {\n        type: Object as PropType<VectorSource>,\n        required: true,\n      },\n      layer: {\n        type: Object as PropType<AnyLayer>,\n        default: () => ({}),\n        required: true,\n      },\n      before: {\n        type: String as PropType<string>,\n        default: '',\n        required: false,\n      },\n    },\n    setup(props) {\n      let map = injectStrict(MapKey);\n      let loaded: Ref<boolean> = ref(false);\n\n      const layer = {\n        ...props.layer,\n        id: props.layerId,\n        source: props.sourceId,\n      };\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Watcher(s)\n       */\n      watch(loaded, (value) => {\n        if (value) {\n          addLayer();\n        }\n      });\n\n      onMounted(() => {\n        addLayer();\n      });\n\n      /**\n       * Reâ€“adds the layer when style changed\n       *\n       * @returns {void}\n       */\n      function addLayer(): void {\n        map.value.addSource(props.sourceId, props.source);\n        map.value.addLayer(layer, props.before);\n      }\n    },\n  });\n</script>\n","<template>\n  <div :id=\"getContainer()\" class=\"v-map-container\">\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type { MapboxOptions, MapEventType } from 'mapbox-gl';\n  import { Map } from 'mapbox-gl';\n  import type { PropType, Ref, SetupContext } from 'vue';\n  import { defineComponent, onMounted, provide, ref } from 'vue';\n  import { mapEvents } from '../constants/events';\n  import { MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VMap',\n    props: {\n      options: {\n        type: Object as PropType<MapboxOptions>,\n        required: true,\n        default: () => ({}),\n      },\n    },\n    setup(props, { emit }: SetupContext) {\n      let map: Ref<Map> = ref({} as Map);\n      let loaded: Ref<boolean> = ref(false);\n      let events: Ref<Array<keyof MapEventType>> = ref(mapEvents);\n\n      onMounted(() => {\n        const options =\n          'container' in props.options\n            ? props.options\n            : { ...props.options, container: 'map' };\n        map.value = new Map(options);\n        loaded.value = true;\n        provide(MapKey, map);\n        listenMapEvents();\n      });\n\n      /**\n       * Listen to map events\n       *\n       * @returns {void}\n       */\n      function listenMapEvents(): void {\n        // Listen for events\n        events.value.forEach((e) => {\n          map.value.on(e, (evt) => {\n            switch (e) {\n              case 'load':\n                emit('loaded', map.value);\n                break;\n              default:\n                emit(e, evt);\n                break;\n            }\n          });\n        });\n      }\n\n      /**\n       * Gets the container element\n       *\n       * @returns {string} - The container element id\n       */\n      const getContainer = (): string => {\n        if (Object.keys(props.options).includes('container')) {\n          return `${props.options.container}`;\n        }\n        return 'map';\n      };\n\n      return {\n        getContainer,\n      };\n    },\n  });\n</script>\n\n<style>\n  canvas {\n    outline: none;\n  }\n\n  .v-map-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n","<template>\n  <div :id=\"getContainer()\" class=\"v-map-container\">\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\">\n  import type { MapboxOptions, MapEventType } from 'mapbox-gl';\n  import { Map } from 'mapbox-gl';\n  import type { PropType, Ref, SetupContext } from 'vue';\n  import { defineComponent, onMounted, provide, ref } from 'vue';\n  import { mapEvents } from '../constants/events';\n  import { MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VMap',\n    props: {\n      options: {\n        type: Object as PropType<MapboxOptions>,\n        required: true,\n        default: () => ({}),\n      },\n    },\n    setup(props, { emit }: SetupContext) {\n      let map: Ref<Map> = ref({} as Map);\n      let loaded: Ref<boolean> = ref(false);\n      let events: Ref<Array<keyof MapEventType>> = ref(mapEvents);\n\n      onMounted(() => {\n        const options =\n          'container' in props.options\n            ? props.options\n            : { ...props.options, container: 'map' };\n        map.value = new Map(options);\n        loaded.value = true;\n        provide(MapKey, map);\n        listenMapEvents();\n      });\n\n      /**\n       * Listen to map events\n       *\n       * @returns {void}\n       */\n      function listenMapEvents(): void {\n        // Listen for events\n        events.value.forEach((e) => {\n          map.value.on(e, (evt) => {\n            switch (e) {\n              case 'load':\n                emit('loaded', map.value);\n                break;\n              default:\n                emit(e, evt);\n                break;\n            }\n          });\n        });\n      }\n\n      /**\n       * Gets the container element\n       *\n       * @returns {string} - The container element id\n       */\n      const getContainer = (): string => {\n        if (Object.keys(props.options).includes('container')) {\n          return `${props.options.container}`;\n        }\n        return 'map';\n      };\n\n      return {\n        getContainer,\n      };\n    },\n  });\n</script>\n\n<style>\n  canvas {\n    outline: none;\n  }\n\n  .v-map-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n","<template>\n  <section :id=\"`popup-${Date.now()}`\" ref=\"content\">\n    <slot />\n  </section>\n</template>\n<script lang=\"ts\">\n  import type { LngLatLike, Map, Marker, PopupOptions } from 'mapbox-gl';\n  import type { PropType, Ref, SetupContext } from 'vue';\n  import { Popup } from 'mapbox-gl';\n  import { defineComponent, onBeforeUnmount, onMounted, ref } from 'vue';\n  import { popupEvents } from '../constants/events';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VPopup',\n    props: {\n      marker: {\n        type: Object as PropType<Marker>,\n        default: () => ({} as Marker),\n        required: false,\n      },\n      options: {\n        type: Object as PropType<PopupOptions>,\n        default: () => ({} as PopupOptions),\n        required: true,\n      },\n      coordinates: {\n        type: Object as PropType<LngLatLike>,\n        default: () => ({}),\n        required: true,\n      },\n    },\n    setup(props, { emit }: SetupContext) {\n      let map: Ref<Map> = injectStrict(MapKey);\n      let popup: Popup = new Popup(props.options);\n      let loaded: Ref<boolean> = ref(true);\n      const content: Ref<null | HTMLElement> = ref(null);\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      onMounted(() => {\n        if (loaded.value) {\n          setPopupContent();\n          setPopupCoordinates();\n          addToMarker();\n          listenPopupEvents();\n        } else {\n          remove();\n          removePopupEvents();\n        }\n      });\n\n      onBeforeUnmount(() => {\n        remove();\n        removePopupEvents();\n      });\n\n      /**\n       * Sets the HTML content for the popup\n       *\n       * @returns {void}\n       */\n      function setPopupContent(): void {\n        popup.setDOMContent(content.value as Node);\n      }\n      /**\n       * Set popup coordinates\n       *\n       * @returns {void}\n       */\n      function setPopupCoordinates(): void {\n        popup.setLngLat(props.coordinates);\n      }\n\n      /**\n       * Add popup to marker if marker exists\n       * else add it to the map.\n       *\n       * @returns {void}\n       */\n      function addToMarker(): void {\n        if (props.marker && Object.keys(props.marker).length !== 0) {\n          props.marker.setPopup(popup);\n        } else {\n          popup.addTo(map.value);\n        }\n        emit('added', { popup });\n      }\n      /**\n       * Remove popup from map\n       *\n       * @returns {void}\n       */\n      function remove(): void {\n        popup.remove();\n        emit('removed');\n      }\n\n      /**\n       * Listen to events\n       *\n       * @returns {void}\n       */\n      function listenPopupEvents(): void {\n        popupEvents.forEach((event: string) => {\n          popup.on(event, () => {\n            emit(event);\n          });\n        });\n      }\n      /**\n       * Turn off listener\n       *\n       * @returns {void}\n       */\n      function removePopupEvents(): void {\n        popupEvents.forEach((event: string) => {\n          popup.off(event, () => {\n            emit(event);\n          });\n        });\n      }\n\n      return {\n        content,\n      };\n    },\n  });\n</script>\n","<template>\n  <section :id=\"`popup-${Date.now()}`\" ref=\"content\">\n    <slot />\n  </section>\n</template>\n<script lang=\"ts\">\n  import type { LngLatLike, Map, Marker, PopupOptions } from 'mapbox-gl';\n  import type { PropType, Ref, SetupContext } from 'vue';\n  import { Popup } from 'mapbox-gl';\n  import { defineComponent, onBeforeUnmount, onMounted, ref } from 'vue';\n  import { popupEvents } from '../constants/events';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VPopup',\n    props: {\n      marker: {\n        type: Object as PropType<Marker>,\n        default: () => ({} as Marker),\n        required: false,\n      },\n      options: {\n        type: Object as PropType<PopupOptions>,\n        default: () => ({} as PopupOptions),\n        required: true,\n      },\n      coordinates: {\n        type: Object as PropType<LngLatLike>,\n        default: () => ({}),\n        required: true,\n      },\n    },\n    setup(props, { emit }: SetupContext) {\n      let map: Ref<Map> = injectStrict(MapKey);\n      let popup: Popup = new Popup(props.options);\n      let loaded: Ref<boolean> = ref(true);\n      const content: Ref<null | HTMLElement> = ref(null);\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      onMounted(() => {\n        if (loaded.value) {\n          setPopupContent();\n          setPopupCoordinates();\n          addToMarker();\n          listenPopupEvents();\n        } else {\n          remove();\n          removePopupEvents();\n        }\n      });\n\n      onBeforeUnmount(() => {\n        remove();\n        removePopupEvents();\n      });\n\n      /**\n       * Sets the HTML content for the popup\n       *\n       * @returns {void}\n       */\n      function setPopupContent(): void {\n        popup.setDOMContent(content.value as Node);\n      }\n      /**\n       * Set popup coordinates\n       *\n       * @returns {void}\n       */\n      function setPopupCoordinates(): void {\n        popup.setLngLat(props.coordinates);\n      }\n\n      /**\n       * Add popup to marker if marker exists\n       * else add it to the map.\n       *\n       * @returns {void}\n       */\n      function addToMarker(): void {\n        if (props.marker && Object.keys(props.marker).length !== 0) {\n          props.marker.setPopup(popup);\n        } else {\n          popup.addTo(map.value);\n        }\n        emit('added', { popup });\n      }\n      /**\n       * Remove popup from map\n       *\n       * @returns {void}\n       */\n      function remove(): void {\n        popup.remove();\n        emit('removed');\n      }\n\n      /**\n       * Listen to events\n       *\n       * @returns {void}\n       */\n      function listenPopupEvents(): void {\n        popupEvents.forEach((event: string) => {\n          popup.on(event, () => {\n            emit(event);\n          });\n        });\n      }\n      /**\n       * Turn off listener\n       *\n       * @returns {void}\n       */\n      function removePopupEvents(): void {\n        popupEvents.forEach((event: string) => {\n          popup.off(event, () => {\n            emit(event);\n          });\n        });\n      }\n\n      return {\n        content,\n      };\n    },\n  });\n</script>\n","<template>\n  <section :id=\"`marker-${Date.now()}`\" class=\"absolute\">\n    <slot :set-ref=\"setSlotRef\" name=\"markers\" />\n    <template v-if=\"isMarkerAvailable\">\n      <v-popup\n        :marker=\"marker\"\n        :options=\"popupOptions\"\n        :coordinates=\"coordinates\"\n      >\n        <slot />\n      </v-popup>\n    </template>\n  </section>\n</template>\n<script lang=\"ts\">\n  import type {\n    EventData,\n    LngLatLike,\n    MarkerOptions,\n    PopupOptions,\n  } from 'mapbox-gl';\n  import { Marker } from 'mapbox-gl';\n  import type { PropType, Ref, SetupContext } from 'vue';\n  import { defineComponent, onMounted, onBeforeUnmount, ref, watch } from 'vue';\n  import { markerDOMEvents, markerMapEvents } from '../constants/events';\n  import VPopup from '../popups/VPopup.vue';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VMarker',\n    components: {\n      VPopup,\n    },\n    props: {\n      options: {\n        type: Object as PropType<MarkerOptions>,\n        default: () => ({} as MarkerOptions),\n        required: true,\n      },\n      popupOptions: {\n        type: Object as PropType<PopupOptions>,\n        default: () => ({} as PopupOptions),\n        required: true,\n      },\n      coordinates: {\n        type: [Object, Array] as PropType<LngLatLike>,\n        default: () => ({}),\n        required: true,\n      },\n      cursor: {\n        type: String as PropType<string>,\n        default: 'pointer',\n        required: false,\n      },\n    },\n    setup(props, { emit }: SetupContext) {\n      let map = injectStrict(MapKey);\n      let marker: Ref<Marker> = ref({}) as Ref<Marker>;\n      let loaded: Ref<boolean> = ref(true);\n      let isMarkerAvailable = ref(false);\n      let slotRef: Ref<HTMLElement | null> = ref(null);\n\n      const setSlotRef = (el: HTMLElement) => {\n        slotRef.value = el;\n      };\n\n      watch(marker, (marker) => {\n        if ('_map' in marker) {\n          isMarkerAvailable.value = true;\n        } else {\n          isMarkerAvailable.value = false;\n        }\n      });\n\n      onMounted(() => {\n        if (loaded.value) {\n          if (slotRef.value !== null) {\n            // add marker to map\n            marker.value = new Marker({\n              element: slotRef.value!,\n              ...props.options,\n            });\n            setMarkerCoordinates(marker.value);\n            addToMap(marker.value);\n            setCursorPointer(marker.value);\n            listenMarkerEvents(marker.value);\n          } else {\n            marker.value = new Marker(props.options);\n            setMarkerCoordinates(marker.value);\n            addToMap(marker.value);\n            setCursorPointer(marker.value);\n            listenMarkerEvents(marker.value);\n          }\n        } else {\n          removeFromMap(marker.value);\n        }\n      });\n\n      onBeforeUnmount(() => {\n        removeFromMap(marker.value);\n      });\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Set marker coordinates\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function setMarkerCoordinates(marker: Marker): void {\n        marker.setLngLat(props.coordinates);\n      }\n      /**\n       * Sets the Cursor to Pointer\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function setCursorPointer(marker: Marker): void {\n        marker.getElement().style.cursor = props.cursor || 'default';\n      }\n\n      /**\n       * Add marker to map\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function addToMap(marker: Marker): void {\n        marker.addTo(map.value);\n        emit('added', { marker });\n      }\n      /**\n       * Remove marker from map\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function removeFromMap(marker: Marker): void {\n        if (isMarkerAvailable.value) {\n          marker.remove();\n          emit('removed');\n        }\n      }\n\n      /**\n       * Listen to events\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function listenMarkerEvents(marker: Marker): void {\n        let coordinates: LngLatLike;\n        // Listen to Marker Mapbox events\n        markerMapEvents.forEach((event: string) => {\n          marker.on(event, (e: EventData) => {\n            if (event === 'dragend') {\n              if (props.coordinates instanceof Array) {\n                coordinates = [e.target._lngLat.lng, e.target._lngLat.lat];\n              } else {\n                coordinates = e.target._lngLat;\n              }\n              emit('update:coordinates', coordinates);\n            }\n            emit(event, e);\n          });\n        });\n        // Listen to Marker DOM events\n        markerDOMEvents.forEach((event: string) => {\n          marker.getElement().addEventListener(event, (e) => {\n            emit(event, e);\n          });\n        });\n      }\n\n      return {\n        isMarkerAvailable,\n        marker,\n        setSlotRef,\n      };\n    },\n  });\n</script>\n<style>\n  .absolute {\n    position: absolute !important;\n  }\n</style>\n","<template>\n  <section :id=\"`marker-${Date.now()}`\" class=\"absolute\">\n    <slot :set-ref=\"setSlotRef\" name=\"markers\" />\n    <template v-if=\"isMarkerAvailable\">\n      <v-popup\n        :marker=\"marker\"\n        :options=\"popupOptions\"\n        :coordinates=\"coordinates\"\n      >\n        <slot />\n      </v-popup>\n    </template>\n  </section>\n</template>\n<script lang=\"ts\">\n  import type {\n    EventData,\n    LngLatLike,\n    MarkerOptions,\n    PopupOptions,\n  } from 'mapbox-gl';\n  import { Marker } from 'mapbox-gl';\n  import type { PropType, Ref, SetupContext } from 'vue';\n  import { defineComponent, onMounted, onBeforeUnmount, ref, watch } from 'vue';\n  import { markerDOMEvents, markerMapEvents } from '../constants/events';\n  import VPopup from '../popups/VPopup.vue';\n  import { injectStrict, MapKey } from '../utils';\n\n  export default defineComponent({\n    name: 'VMarker',\n    components: {\n      VPopup,\n    },\n    props: {\n      options: {\n        type: Object as PropType<MarkerOptions>,\n        default: () => ({} as MarkerOptions),\n        required: true,\n      },\n      popupOptions: {\n        type: Object as PropType<PopupOptions>,\n        default: () => ({} as PopupOptions),\n        required: true,\n      },\n      coordinates: {\n        type: [Object, Array] as PropType<LngLatLike>,\n        default: () => ({}),\n        required: true,\n      },\n      cursor: {\n        type: String as PropType<string>,\n        default: 'pointer',\n        required: false,\n      },\n    },\n    setup(props, { emit }: SetupContext) {\n      let map = injectStrict(MapKey);\n      let marker: Ref<Marker> = ref({}) as Ref<Marker>;\n      let loaded: Ref<boolean> = ref(true);\n      let isMarkerAvailable = ref(false);\n      let slotRef: Ref<HTMLElement | null> = ref(null);\n\n      const setSlotRef = (el: HTMLElement) => {\n        slotRef.value = el;\n      };\n\n      watch(marker, (marker) => {\n        if ('_map' in marker) {\n          isMarkerAvailable.value = true;\n        } else {\n          isMarkerAvailable.value = false;\n        }\n      });\n\n      onMounted(() => {\n        if (loaded.value) {\n          if (slotRef.value !== null) {\n            // add marker to map\n            marker.value = new Marker({\n              element: slotRef.value!,\n              ...props.options,\n            });\n            setMarkerCoordinates(marker.value);\n            addToMap(marker.value);\n            setCursorPointer(marker.value);\n            listenMarkerEvents(marker.value);\n          } else {\n            marker.value = new Marker(props.options);\n            setMarkerCoordinates(marker.value);\n            addToMap(marker.value);\n            setCursorPointer(marker.value);\n            listenMarkerEvents(marker.value);\n          }\n        } else {\n          removeFromMap(marker.value);\n        }\n      });\n\n      onBeforeUnmount(() => {\n        removeFromMap(marker.value);\n      });\n\n      map.value.on('style.load', () => {\n        // https://github.com/mapbox/mapbox-gl-js/issues/2268#issuecomment-401979967\n        const styleTimeout = () => {\n          if (!map.value.isStyleLoaded()) {\n            loaded.value = false;\n            setTimeout(styleTimeout, 200);\n          } else {\n            loaded.value = true;\n          }\n        };\n        styleTimeout();\n      });\n\n      /**\n       * Set marker coordinates\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function setMarkerCoordinates(marker: Marker): void {\n        marker.setLngLat(props.coordinates);\n      }\n      /**\n       * Sets the Cursor to Pointer\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function setCursorPointer(marker: Marker): void {\n        marker.getElement().style.cursor = props.cursor || 'default';\n      }\n\n      /**\n       * Add marker to map\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function addToMap(marker: Marker): void {\n        marker.addTo(map.value);\n        emit('added', { marker });\n      }\n      /**\n       * Remove marker from map\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function removeFromMap(marker: Marker): void {\n        if (isMarkerAvailable.value) {\n          marker.remove();\n          emit('removed');\n        }\n      }\n\n      /**\n       * Listen to events\n       *\n       * @param {Marker} marker - Marker\n       * @returns {void}\n       */\n      function listenMarkerEvents(marker: Marker): void {\n        let coordinates: LngLatLike;\n        // Listen to Marker Mapbox events\n        markerMapEvents.forEach((event: string) => {\n          marker.on(event, (e: EventData) => {\n            if (event === 'dragend') {\n              if (props.coordinates instanceof Array) {\n                coordinates = [e.target._lngLat.lng, e.target._lngLat.lat];\n              } else {\n                coordinates = e.target._lngLat;\n              }\n              emit('update:coordinates', coordinates);\n            }\n            emit(event, e);\n          });\n        });\n        // Listen to Marker DOM events\n        markerDOMEvents.forEach((event: string) => {\n          marker.getElement().addEventListener(event, (e) => {\n            emit(event, e);\n          });\n        });\n      }\n\n      return {\n        isMarkerAvailable,\n        marker,\n        setSlotRef,\n      };\n    },\n  });\n</script>\n<style>\n  .absolute {\n    position: absolute !important;\n  }\n</style>\n"],"names":["MapKey","Symbol","injectStrict","key","fallback","resolved","inject","Error","description","props","options","customAttribution","position","type","String","required","setup","slots","onMounted","control","AttributionControl","map","value","addControl","default","geolocateControlEvents","emit","events","forEach","event","on","ScaleControl","name","layerId","before","loaded","ref","id","data","addLayer","layer","isStyleLoaded","styleTimeout","Object","GeoJsonLayer","sourceId","source","addSource","mapLayerEvents","mapEvents","markerMapEvents","markerDOMEvents","popupEvents","watch","prevSource","e","evt","onBeforeUnmount","getLayer","removeLayer","removeSource","container","provide","_ctx","getContainer","class","marker","popup","Popup","content","remove","removePopupEvents","off","setDOMContent","setLngLat","coordinates","VPopup","Array","cursor","isMarkerAvailable","slotRef","setCursorPointer","addToMap","removeFromMap","setMarkerCoordinates","listenMarkerEvents","Marker","el","popupOptions"],"mappings":";;;;;sbAGA,MAAAA,EAAAC,OAAA,OCOA,SAAAC,EAAAC,EAAAC,GACA,MAAAC,EAAAC,EAAAA,OAAAH,EAAAC,GACA,IAAAC,EACA,MAAA,IAAAE,MAAA,qBAAAJ,EAAAK,eAEA,OAAAH,sDCFII,MAAA,CACEC,QAAA,sCAOIC,kBAAA,kCAIJC,SAAA,CACEC,KAAAC,kCAIAC,UAAA,IAGJC,MAAAP,GAAAQ,MAAAA,eAGEC,EAAAA,WAAA,6BAWIT,EAAAC,qGAMF,MAAAS,EAAA,IAAAC,qBAAAV,GACAW,EAAAC,MAAAC,WAAAJ,EAAAV,EAAAG,+OC7CJH,MAAA,CACEC,QAAA,aAEEc,QAAA,KAAA,iBAGFZ,SAAA,CACEC,KAAAC,8BAIAC,UAAA,wBAMFG,EAAAA,WAAA,4DAWEG,EAAAC,MAAAC,WAAAJ,EAAAV,EAAAG,kECrCR,MAAAa,EAAA,CACA,YACA,QACA,iBACA,yBACA,2ECKIhB,MAAA,CACEC,QAAA,aAQEc,QAAA,KAAA,iBAGFZ,SAAA,CACEC,KAAAC,8BAIAC,UAAA,IAGJC,MAAAP,GAAAiB,KAAAA,eAGER,EAAAA,WAAA,2DAWEG,EAAAC,MAAAC,WAAAJ,EAAAV,EAAAG,UACAe,EAAAC,SAAAC,IACEV,EAAAW,GAAAD,GAAA,0HCtCNpB,MAAA,CACEC,QAAA,aAMEc,QAAA,KAAA,iBAGFZ,SAAA,CACEC,KAAAC,8BAIAC,UAAA,wBAMFG,EAAAA,WAAA,4DAWEG,EAAAC,MAAAC,WAAAJ,EAAAV,EAAAG,qHChCJH,MAAA,CACEC,QAAA,aAEEc,QAAA,KAAA,iBAGFZ,SAAA,CACEC,KAAAC,iCAIAC,UAAA,wBAMFG,EAAAA,WAAA,iBAUE,MAAAC,EAAA,IAAAY,EAAAA,aAAAtB,EAAAC,SACAW,EAAAC,MAAAC,WAAAJ,EAAAV,EAAAG,sFC1BJoB,KAAA,gBACAvB,MAAA,CACEwB,QAAA,qFASAvB,QAAA,0BAIAwB,OAAA,wBAGEnB,UAAA,wBAKFoB,EAAAC,OAAA,iCAGE3B,EAAAC,QACA2B,GAAA5B,EAAAwB,QACAK,KAAA7B,EAAA6B,oCAoCAjB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QAhCFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKFJ,EAAAA,WAAA,iHCpDFT,MAAA,CACEwB,QAAA,aAEET,QAAA,2CAIAX,KAAA8B,oBAGFjC,QAAA,0BAIAwB,OAAA,wBAGEnB,UAAA,wBAKFoB,EAAAC,OAAA,iCAGE3B,EAAAC,QACA2B,GAAA5B,EAAAwB,QACAK,KAAA7B,EAAA6B,KACAzB,KAAA+B,EAAAA,4BAmCAvB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QAhCFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKFJ,EAAAA,WAAA,sHCnDFT,MAAA,CACEoC,SAAA,aAEErB,QAAA,uCAGFS,QAAA,aAEET,QAAA,sCAGFsB,OAAA,CACEjC,KAAA8B,oBAGFH,MAAA,CACE3B,KAAA8B,OACAnB,QAAA,KAAA,iBAGFU,OAAA,wBAGEnB,UAAA,wBAKFoB,EAAAC,OAAA,eAGE3B,EAAA+B,MACAH,GAAA5B,EAAAwB,QACAa,OAAArC,EAAAoC,aAGAhC,KAAA,UACAyB,KAAA7B,EAAAqC,qBAmCAzB,EAAAC,MAAAyB,UAAAtC,EAAAoC,SAAAC,GACAzB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QAjCFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKFJ,EAAAA,WAAA,4LC1EN,MAAA8B,EAAA,CACA,QACA,WACA,YACA,UACA,YACA,aACA,aACA,YACA,WACA,cACA,aACA,WACA,eCbAC,EAAA,CACA,QACA,OACA,OACA,SACA,SACA,SACA,mBACA,uBACA,cACA,OACA,kBACA,oBACA,mBACA,aACA,YACA,gBACA,eACA,aACA,cACA,YACA,WACA,aACA,QACA,cACA,WACA,YACA,UACA,YACA,WACA,YACA,YACA,OACA,UACA,YACA,OACA,UACA,cACA,SACA,YACA,YACA,OACA,UACA,aACA,QACA,WACA,SChDAC,EAAA,CAAA,YAAA,OAAA,WACAC,EAAA,CAAA,QAAA,aAAA,cCDAC,EAAA,CAAA,OAAA,6DCkBI3C,MAAA,CACEoC,SAAA,aAEErB,QAAA,wCAGFS,QAAA,aAEET,QAAA,uCAGFsB,OAAA,CACEjC,KAAA8B,oBAGFH,MAAA,CACE3B,KAAA8B,OACAnB,QAAA,KAAA,iBAGFU,OAAA,wBAGEnB,UAAA,IAGJC,MAAAP,GAAAiB,KAAAA,eAEES,EAAAC,OAAA,GACAT,EAAAS,MAAAY,eAGEvC,EAAA+B,MACAH,GAAA5B,EAAAwB,QACAa,OAAArC,EAAAoC,8DAiEAxB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QA9DFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKF+B,EAAAA,OAAA,IAAA5C,EAAAqC,SAAA,CAAAA,EAAAQ,sDAIApC,EAAAA,WAAA,8BAaIG,EAAAC,MAAAQ,GAAAyB,EAAA9C,EAAAwB,SAAAuB,oBAMJC,EAAAA,iBAAA,KAKEpC,EAAAC,MAAAoC,SAAAjD,EAAAwB,WACEZ,EAAAC,MAAAqC,YAAAlD,EAAAwB,SACAZ,EAAAC,MAAAsC,aAAAnD,EAAAoC,iPC9FNpC,MAAA,CACEoC,SAAA,aAEErB,QAAA,sCAGFS,QAAA,aAEET,QAAA,qCAGFsB,OAAA,CACEjC,KAAA8B,oBAGFH,MAAA,CACE3B,KAAA8B,OACAnB,QAAA,KAAA,iBAGFU,OAAA,wBAGEnB,UAAA,wBAKFoB,EAAAC,OAAA,eAGE3B,EAAA+B,MACAH,GAAA5B,EAAAwB,QACAa,OAAArC,EAAAoC,8DAoCAxB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QAjCFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKFJ,EAAAA,WAAA,8OCzDFT,MAAA,CACEoC,SAAA,aAEErB,QAAA,uCAGFS,QAAA,aAEET,QAAA,sCAGFsB,OAAA,CACEjC,KAAA8B,oBAGFH,MAAA,CACE3B,KAAA8B,OACAnB,QAAA,KAAA,iBAGFU,OAAA,wBAGEnB,UAAA,wBAKFoB,EAAAC,OAAA,eAGE3B,EAAA+B,MACAH,GAAA5B,EAAAwB,QACAa,OAAArC,EAAAoC,aAGAhC,KAAA,UACAyB,KAAA7B,EAAAqC,qBAmCAzB,EAAAC,MAAAyB,UAAAtC,EAAAoC,SAAAC,GACAzB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QAjCFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKFJ,EAAAA,WAAA,+OC/DFT,MAAA,CACEoC,SAAA,aAEErB,QAAA,uCAGFS,QAAA,aAEET,QAAA,sCAGFsB,OAAA,CACEjC,KAAA8B,oBAGFH,MAAA,CACE3B,KAAA8B,OACAnB,QAAA,KAAA,iBAGFU,OAAA,wBAGEnB,UAAA,wBAKFoB,EAAAC,OAAA,eAGE3B,EAAA+B,MACAH,GAAA5B,EAAAwB,QACAa,OAAArC,EAAAoC,8DAoCAxB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QAjCFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKFJ,EAAAA,WAAA,8OC1DFT,MAAA,CACEoC,SAAA,aAEErB,QAAA,sCAGFS,QAAA,aAEET,QAAA,qCAGFsB,OAAA,CACEjC,KAAA8B,oBAGFH,MAAA,CACE3B,KAAA8B,OACAnB,QAAA,KAAA,iBAGFU,OAAA,wBAGEnB,UAAA,wBAKFoB,EAAAC,OAAA,eAGE3B,EAAA+B,MACAH,GAAA5B,EAAAwB,QACAa,OAAArC,EAAAoC,8DAoCAxB,EAAAC,MAAAiB,SAAAC,EAAA/B,EAAAyB,QAjCFb,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,sBAOApB,UAKFJ,EAAAA,WAAA,gOCxDFT,MAAA,CACEC,QAAA,CACEG,KAAA8B,mBAEAnB,QAAA,KAAA,MAGJR,MAAAP,GAAAiB,KAAAA,oBAEES,EAAAC,OAAA,cAGAlB,EAAAA,WAAA,+CAIM,IAAAT,EAAAC,QAAAmD,UAAA,4BAEJ1B,EAAAb,OAAA,EACAwC,UAAA9D,EAAAqB,mDAaIkC,sCAwBN,MAAA,+DALI,GAAA9C,EAAAC,QAAAmD,qHCjEFxB,GAAA0B,EAAAC,eAAoBC,MAAA,+HCcxBxD,MAAA,CACEyD,OAAA,8BAGEnD,UAAA,GAEFL,QAAA,CACEG,KAAA8B,OACAnB,QAAA,KAAA,8BAIAX,KAAA8B,OACAnB,QAAA,KAAA,kBAIJR,MAAAP,GAAAiB,KAAAA,IACE,IAAAL,EAAAnB,EAAAF,GACAmE,EAAA,IAAAC,EAAAA,MAAA3D,EAAAC,SACAyB,EAAAC,OAAA,GACA,MAAAiC,EAAAjC,MAAA,MAoEA,SAAAkC,IACEH,EAAAG,SACA5C,EAAA,WAoBF,SAAA6C,IACEnB,EAAAxB,SAAAC,IACEsC,EAAAK,IAAA3C,GAAA,gBAMJ,OAhGAR,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,OAGFxB,EAAAA,WAAA,KACEiB,EAAAb,OAsBA6C,EAAAM,cAAAJ,EAAA/C,OAQA6C,EAAAO,UAAAjE,EAAAkE,yGAeAjD,EAAA,QAAA,CAAAyC,aAkBAf,EAAAxB,SAAAC,IACEsC,EAAArC,GAAAD,GAAA,kBA1DAyC,IACAC,QAIJd,EAAAA,iBAAA,KACEa,IACAC,OAqEF,CACEF,0ICtI+BjC,IAAA,8GC4BnCJ,KAAA,sBAEE4C,OAAAA,GAEFnE,MAAA,CACEC,QAAA,CACEG,KAAA8B,OACAnB,QAAA,KAAA,+BAIAX,KAAA8B,OACAnB,QAAA,KAAA,8BAIAX,KAAA,CAAA8B,OAAAkC,OACArD,QAAA,KAAA,iBAGFsD,OAAA,aAEEtD,QAAA,UACAT,UAAA,IAGJC,MAAAP,GAAAiB,KAAAA,eAEEwC,EAAA9B,MAAA,IACAD,EAAAC,OAAA,GACA2C,EAAA3C,OAAA,GACA4C,EAAA5C,MAAA,oBA8DE8B,EAAAQ,UAAAjE,EAAAkE,aAQF,SAAAM,EAAAf,mDAUA,SAAAgB,EAAAhB,0CAUA,SAAAiB,EAAAjB,aAEIA,EAAAI,SACA5C,EAAA,gCAaFwB,EAAAtB,SAAAC,IACEqC,EAAApC,GAAAD,GAAA0B,IACE,YAAA1B,MACEpB,EAAAkE,uBAAAE,mEAKAnD,EAAA,qBAAAiD,iBAMNxB,EAAAvB,SAAAC,wDAOF,8BAxHE,SAAAqC,KAOFhD,EAAAA,WAAA,KACEiB,EAAAb,+DAKMb,EAAAC,UAEF0E,EAAAlB,EAAA5C,kBAEA2D,EAAAf,EAAA5C,OACA+D,EAAAnB,EAAA5C,SAEA4C,EAAA5C,MAAA,IAAAgE,EAAAA,OAAA7E,EAAAC,SACA0E,EAAAlB,EAAA5C,kBAEA2D,EAAAf,EAAA5C,OACA+D,EAAAnB,EAAA5C,sBAONmC,EAAAA,iBAAA,mBAIApC,EAAAC,MAAAQ,GAAA,cAAA,kBAGIT,EAAAC,MAAAmB,gBAIEN,EAAAb,OAAA,GAHAa,EAAAb,OAAA,sBAMJoB,OA2EF,CACEqC,oBACAb,oBA/HFqB,IACEP,EAAA1D,MAAAiE,0KC9DgCtB,MAAA,8HAI/BC,OAAAH,EAAAG,OACAxD,QAAAqD,EAAAyB,aACAb,YAAAZ,EAAAY"}